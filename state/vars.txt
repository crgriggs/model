MODULE State

INPUT

opcode : opcodes;

VAR
ss_limit : BITVEC[19];
ss_selector : BITVEC[15];
rax : BITVEC[63];
rbx : BITVEC[63];
rcx : BITVEC[63];
rdx : BITVEC[63];
rflags : BITVEC[63];
r11 : BITVEC[63];
ss_base : BITVEC[31];
ss_accessRights : BITVEC[11];
EFER : BITVEC[63];
cs_base : BITVEC[31];
rip : BITVEC[63];
cs_selector : BITVEC[15];
cs_limit : BITVEC[19];
cpl : BITVEC[1];
cs_accessRights : BITVEC[11];
CR0 : BITVEC[63];
CR4 : BITVEC[63];
currentReg : register;
opcode : opcodes;
memory : FUNC[1];
rsp : BITVEC[63];
exceptionThrown : TRUTH;

CONST

i : TERM;
m0 : FUNC[1];
addr  : BITVEC[63];
SRC : BITVEC[63];

ss_limit_i : BITVEC[19];
ss_selector_i : BITVEC[15];
rax_i : BITVEC[63];
rbx_i : BITVEC[63];
rcx_i : BITVEC[63];
rdx_i : BITVEC[63];
rflags_i : BITVEC[63];
r11_i : BITVEC[63];
ss_base_i : BITVEC[31];
ss_accessRights_i : BITVEC[11];
EFER_i : BITVEC[63];
cs_base_i : BITVEC[31];
rip_i : BITVEC[63];
cs_selector_i : BITVEC[15];
cs_limit_i : BITVEC[19];
cpl_i : BITVEC[1];
cs_accessRights_i : BITVEC[11];
CR0_i : BITVEC[63];
CR4_i : BITVEC[63];
rsp_i : BITVEC[63];

DEFINE

ASSIGN

init[currentReg] := {a, b, c, d};
next[currentReg] := {a, b, c, d};

init[memory] := Lambda(i). m0(i);
next[memory] := Lambda(i).
(* at each step, write "data" into the address "addr" *)
	case
		addr = next[pushInstr.rsp] & opcode = push : SRC; (* only change the content of "addr" *)
		default : memory(i); (* content of other addr remains unchanged *)
	esac;
