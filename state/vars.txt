MODULE State

INPUT

VAR
ss_limit : BITVEC[20];
ss_selector : BITVEC[16];
rax : BITVEC[64];
rbx : BITVEC[64];
rcx : BITVEC[64];
rdx : BITVEC[64];
rflags : BITVEC[64];
r11 : BITVEC[64];
ss_base : BITVEC[32];
ss_accessRights : BITVEC[12];
EFER : BITVEC[64];
cs_base : BITVEC[32];
rip : BITVEC[64];
cs_selector : BITVEC[16];
cs_limit : BITVEC[20];
cpl : BITVEC[2];
cs_accessRights : BITVEC[12];
CR0 : BITVEC[64];
CR4 : BITVEC[64];
currentReg : register;
opcode : opcodes;
memory : FUNC[1];

CONST

i : TERM;
m0 : FUNC[1];

DEFINE

ASSIGN

init[currentReg] := {a, b, c, d};
next[currentReg] := {a, b, c, d};

init[memory] := Lambda(i). m0(i);
next[memory] := Lambda(i).
(* at each step, write "data" into the address "addr" *)
	case
		addr = push.rsp & opcode = push : push.memory; (* only change the content of "addr" *)
		default : memory(i); (* content of other addr remains unchanged *)
	esac;
