MODEL StateModel

typedef opcodes : enum{sysret, push, mov, pop, syscall};
typedef exitCase : enum {GP, UD, Normal};
typedef register : enum {a, b, c, d};
typedef size : enum {bits64, bits32, bits16};

CONST
(*----- ./models//sysret.txt -----*)
MODULE sysretInstr

INPUT

State.ss_limit : BITVEC[20];
State.ss_selector : BITVEC[16];
State.cpl : BITVEC[2];
State.rflags : BITVEC[64];
State.r11 : BITVEC[64];
State.ss_base : BITVEC[32];
State.ss_accessRights : BITVEC[12];
State.EFER : BITVEC[64];
State.cs_base : BITVEC[32];
State.rip : BITVEC[64];
State.cs_selector : BITVEC[16];
State.cs_limit : BITVEC[20];
isCanonical : TRUTH;
State.rcx : BITVEC[64];
State.cs_accessRights : BITVEC[12];

VAR
ss_base : BITVEC[32];
exitStatus: exitCase;
cpl : BITVEC[2];
ss_limit : BITVEC[20];
cs_selector : BITVEC[16];
ss_accessRights : BITVEC[12];
rip : BITVEC[64];
cs_accessRights : BITVEC[12];
cs_base : BITVEC[32];
cs_limit : BITVEC[20];
ss_selector : BITVEC[16];
rflags : BITVEC[64];

CONST
IA32_STAR: BITVEC[64];
operand_size_is_64_bit: TRUTH;

ss_base_i : BITVEC[32];
cpl_i : BITVEC[2];
ss_limit_i : BITVEC[20];
cs_selector_i : BITVEC[16];
ss_accessRights_i : BITVEC[12];
rip_i : BITVEC[64];
cs_accessRights_i : BITVEC[12];
cs_base_i : BITVEC[32];
cs_limit_i : BITVEC[20];
ss_selector_i : BITVEC[16];
rflags_i : BITVEC[64];

DEFINE

b0 := ( 0 # [0:0] );
b1 := ( 1 # [0:0] );
ucl_hex_0 := ( b0 @ b0 @ b0 @ b0);
ucl_hex_1 := ( b0 @ b0 @ b0 @ b1);
ucl_hex_2 := ( b0 @ b0 @ b1 @ b0);
ucl_hex_3 := ( b0 @ b0 @ b1 @ b1);
ucl_hex_4 := ( b0 @ b1 @ b0 @ b0);
ucl_hex_5 := ( b0 @ b1 @ b0 @ b1);
ucl_hex_6 := ( b0 @ b1 @ b1 @ b0);
ucl_hex_7 := ( b0 @ b1 @ b1 @ b1);
ucl_hex_8 := ( b1 @ b0 @ b0 @ b0);
ucl_hex_9 := ( b1 @ b0 @ b0 @ b1);
ucl_hex_a := ( b1 @ b0 @ b1 @ b0);
ucl_hex_b := ( b1 @ b0 @ b1 @ b1);
ucl_hex_c := ( b1 @ b1 @ b0 @ b0);
ucl_hex_d := ( b1 @ b1 @ b0 @ b1);
ucl_hex_e := ( b1 @ b1 @ b1 @ b0);
ucl_hex_f := ( b1 @ b1 @ b1 @ b1);

RFLAGS := State.rflags;
RCX := State.rcx;
IA32_EFER.SCE := State.EFER # [0:0];
CS.L := State.cs_accessRights # [2:2];
R11 := State.r11;
ECX := State.rcx # [31:0];
CPL := State.cpl;
IA32_EFER.LMA := State.EFER # [10:10];
RIP := State.rip;
CS.G := ( b1 );
SS.DPL := ( (b1)@(b1) );
SS.G := ( b1 );
SS.P := ( b1 );
CS.P := ( b1 );
CS.Type := ( (ucl_hex_b) );
SS.S := ( b1 );
CS.DPL := ( (b1)@(b1) );
SS.Type := ( (ucl_hex_3) );
SS.B := ( b1 );
CS.S := ( b1 );
CS.AVL := State.cs_accessRights # [3:3];
CS.B := State.cs_accessRights # [1:1];
CS.D := State.cs_accessRights # [1:1];
CS.L := State.cs_accessRights # [2:2];
SS.AVL := State.ss_accessRights # [3:3];
SS.D := State.ss_accessRights # [1:1];
SS.L := State.ss_accessRights # [2:2];
CS.L0 := case
    operand_size_is_64_bit : ( b0 );
    operand_size_is_64_bit : ( b1 );
    default : State.cs_accessRights # [2:2];
esac;

CS.L_n := CS.L0;

CS.D0 := case
    operand_size_is_64_bit : ( b1 );
    operand_size_is_64_bit : ( b0 );
    default : State.cs_accessRights # [1:1];
esac;

CS.D_n := CS.D0;

exitStatus0 := case
    CPL != 0 | isCanonical : GP;
    CS.L != 1 | IA32_EFER.LMA != 1 | IA32_EFER.SCE != 1 : UD;
    default : Normal;
esac;

exitStatus_n := exitStatus0;

RIP0 := case
    operand_size_is_64_bit : ( ECX );
    operand_size_is_64_bit : ( RCX );
    default : RIP;
esac;

RIP_n := RIP0;

CS.Selector0 := case
    operand_size_is_64_bit : ( IA32_STAR # [63:48] );
    operand_size_is_64_bit : ( IA32_STAR # [63:48] ) +_16 ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_1) @ (ucl_hex_0) );
    default : State.cs_selector;
esac;

CS.Selector_n := CS.Selector0;


ASSIGN

init[ss_base] := ss_base_i;
next[ss_base] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) );
    default : State.ss_base;
esac;

init[exitStatus] := Normal;
next[exitStatus] := exitStatus_n;

init[cpl] := cpl_i;
next[cpl] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( (b1)@(b1) );
    default : State.cpl;
esac;

init[ss_limit] := ss_limit_i;
next[ss_limit] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) );
    default : State.ss_limit;
esac;

init[cs_selector] := cs_selector_i;
next[cs_selector] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( CS.Selector_n ) || ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_3) );
    default : State.cs_selector;
esac;

init[ss_accessRights] := ss_accessRights_i;
next[ss_accessRights] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( ( SS.Type ) ) @ ( ( SS.S ) ) @ ( ( SS.DPL ) ) @ ( ( SS.P ) ) @ ( ( SS.AVL ) ) @ ( ( SS.L ) ) @ ( ( SS.D ) ) @ ( ( SS.B ) ) @ ( ( SS.G ) );
    default : State.ss_accessRights;
esac;

init[rip] := rip_i;
next[rip] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( RIP_n );
    default : State.rip;
esac;

init[cs_accessRights] := cs_accessRights_i;
next[cs_accessRights] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( ( CS.Type ) ) @ ( ( CS.S ) ) @ ( ( CS.DPL ) ) @ ( ( CS.P ) ) @ ( ( CS.AVL ) ) @ ( ( CS.L_n ) ) @ ( ( CS.D_n ) ) @ ( ( CS.B ) ) @ ( ( CS.G ) );
    default : State.cs_accessRights;
esac;

init[cs_base] := cs_base_i;
next[cs_base] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) );
    default : State.cs_base;
esac;

init[cs_limit] := cs_limit_i;
next[cs_limit] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) );
    default : State.cs_limit;
esac;

init[ss_selector] := ss_selector_i;
next[ss_selector] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( IA32_STAR # [63:48] ) +_16 ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_8) ) || ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_3) );
    default : State.ss_selector;
esac;

init[rflags] := rflags_i;
next[rflags] := case
    next[exitStatus] != UD & next[exitStatus] != GP : ( R11 ) && ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_3) @ (ucl_hex_c) @ (ucl_hex_7) @ (ucl_hex_f) @ (ucl_hex_d) @ (ucl_hex_7) ) || ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_2) );
    default : State.rflags;
esac;


(*----- ./models//push.txt -----*)
MODULE pushInstr

INPUT

State.rsp : BITVEC[64];
State.memory : FUNC[1];

VAR
OperandSize : size;
StackAddrSize : size;
rsp : BITVEC[64];
memory : BITVEC[64];

CONST
SRC: BITVEC[64];

rsp_i : BITVEC[64];
memory_i : BITVEC[64];

DEFINE

b0 := ( 0 # [0:0] );
b1 := ( 1 # [0:0] );
ucl_hex_0 := ( b0 @ b0 @ b0 @ b0);
ucl_hex_1 := ( b0 @ b0 @ b0 @ b1);
ucl_hex_2 := ( b0 @ b0 @ b1 @ b0);
ucl_hex_3 := ( b0 @ b0 @ b1 @ b1);
ucl_hex_4 := ( b0 @ b1 @ b0 @ b0);
ucl_hex_5 := ( b0 @ b1 @ b0 @ b1);
ucl_hex_6 := ( b0 @ b1 @ b1 @ b0);
ucl_hex_7 := ( b0 @ b1 @ b1 @ b1);
ucl_hex_8 := ( b1 @ b0 @ b0 @ b0);
ucl_hex_9 := ( b1 @ b0 @ b0 @ b1);
ucl_hex_a := ( b1 @ b0 @ b1 @ b0);
ucl_hex_b := ( b1 @ b0 @ b1 @ b1);
ucl_hex_c := ( b1 @ b1 @ b0 @ b0);
ucl_hex_d := ( b1 @ b1 @ b0 @ b1);
ucl_hex_e := ( b1 @ b1 @ b1 @ b0);
ucl_hex_f := ( b1 @ b1 @ b1 @ b1);

RSP := State.rsp;
ESP := State.rsp # [31:0];
SP := State.rsp # [15:0];
SP0 := case
    OperandSize = bits32 & StackAddrSize != bits32 & (StackAddrSize != bits64) : SP - 4;
    OperandSize != bits32 & (StackAddrSize != bits32 & (StackAddrSize != bits64)) : SP - 2;
    default : SP;
esac;

SP_n := SP0;

RSP0 := case
    OperandSize = bits32 & OperandSize != bits64 & (StackAddrSize = bits64) : ( RSP ) -_64 ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_4) );
    OperandSize = bits64 & StackAddrSize = bits64 : ( RSP ) -_64 ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_8) );
    OperandSize != bits32 & (OperandSize != bits64 & (StackAddrSize = bits64)) : ( RSP ) -_64 ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_2) );
    default : RSP;
esac;

RSP_n := RSP0;

ESP0 := case
    OperandSize = bits64 & StackAddrSize = bits32 & StackAddrSize != bits64 : ESP - 8;
    OperandSize = bits32 & OperandSize != bits64 & (StackAddrSize = bits32 & StackAddrSize != bits64) : ESP - 4;
    OperandSize != bits32 & (OperandSize != bits64 & (StackAddrSize = bits32 & StackAddrSize != bits64)) : ESP - 2;
    default : ESP;
esac;

ESP_n := ESP0;

memory0 := case
    OperandSize = bits32 & OperandSize != bits64 & (StackAddrSize = bits32 & StackAddrSize != bits64) : ( SRC );
    OperandSize != bits32 & (OperandSize != bits64 & (StackAddrSize = bits32 & StackAddrSize != bits64)) : ( SRC );
    OperandSize = bits32 & StackAddrSize != bits32 & (StackAddrSize != bits64) : ( SRC );
    OperandSize != bits32 & (StackAddrSize != bits32 & (StackAddrSize != bits64)) : ( SRC );
    OperandSize = bits64 & StackAddrSize = bits64 : ( SRC );
    OperandSize = bits32 & OperandSize != bits64 & (StackAddrSize = bits64) : ( SRC );
    OperandSize != bits32 & (OperandSize != bits64 & (StackAddrSize = bits64)) : ( SRC );
    OperandSize = bits64 & StackAddrSize = bits32 & StackAddrSize != bits64 : ( SRC );
    default : State.memory(State.rsp);
esac;

memory_n := memory0;


ASSIGN

init[OperandSize] := {bits64, bits32, bits16};
next[OperandSize] := {bits64, bits32, bits16};

init[StackAddrSize] := {bits64, bits32, bits16};
next[StackAddrSize] := {bits64, bits32, bits16};

init[rsp] := rsp_i;
next[rsp] := RSP_n;

init[memory] := memory_i;
next[memory] := memory_n;


(*----- ./models//mov.txt -----*)
MODULE movInstr

INPUT


VAR
DEST : BITVEC[64];

CONST
SRC: BITVEC[64];

DEST_i : BITVEC[64];

DEFINE

b0 := ( 0 # [0:0] );
b1 := ( 1 # [0:0] );
ucl_hex_0 := ( b0 @ b0 @ b0 @ b0);
ucl_hex_1 := ( b0 @ b0 @ b0 @ b1);
ucl_hex_2 := ( b0 @ b0 @ b1 @ b0);
ucl_hex_3 := ( b0 @ b0 @ b1 @ b1);
ucl_hex_4 := ( b0 @ b1 @ b0 @ b0);
ucl_hex_5 := ( b0 @ b1 @ b0 @ b1);
ucl_hex_6 := ( b0 @ b1 @ b1 @ b0);
ucl_hex_7 := ( b0 @ b1 @ b1 @ b1);
ucl_hex_8 := ( b1 @ b0 @ b0 @ b0);
ucl_hex_9 := ( b1 @ b0 @ b0 @ b1);
ucl_hex_a := ( b1 @ b0 @ b1 @ b0);
ucl_hex_b := ( b1 @ b0 @ b1 @ b1);
ucl_hex_c := ( b1 @ b1 @ b0 @ b0);
ucl_hex_d := ( b1 @ b1 @ b0 @ b1);
ucl_hex_e := ( b1 @ b1 @ b1 @ b0);
ucl_hex_f := ( b1 @ b1 @ b1 @ b1);


ASSIGN

init[DEST] := DEST_i;
next[DEST] := SRC;


(*----- ./models//pop.txt -----*)
MODULE popInstr

INPUT

State.rsp : BITVEC[64];
State.memory : FUNC[1];

VAR
DEST : BITVEC[64];
StackAddrSize : size;
rsp : BITVEC[64];
OperandSize : size;

CONST

DEST_i : BITVEC[64];
rsp_i : BITVEC[64];

DEFINE

b0 := ( 0 # [0:0] );
b1 := ( 1 # [0:0] );
ucl_hex_0 := ( b0 @ b0 @ b0 @ b0);
ucl_hex_1 := ( b0 @ b0 @ b0 @ b1);
ucl_hex_2 := ( b0 @ b0 @ b1 @ b0);
ucl_hex_3 := ( b0 @ b0 @ b1 @ b1);
ucl_hex_4 := ( b0 @ b1 @ b0 @ b0);
ucl_hex_5 := ( b0 @ b1 @ b0 @ b1);
ucl_hex_6 := ( b0 @ b1 @ b1 @ b0);
ucl_hex_7 := ( b0 @ b1 @ b1 @ b1);
ucl_hex_8 := ( b1 @ b0 @ b0 @ b0);
ucl_hex_9 := ( b1 @ b0 @ b0 @ b1);
ucl_hex_a := ( b1 @ b0 @ b1 @ b0);
ucl_hex_b := ( b1 @ b0 @ b1 @ b1);
ucl_hex_c := ( b1 @ b1 @ b0 @ b0);
ucl_hex_d := ( b1 @ b1 @ b0 @ b1);
ucl_hex_e := ( b1 @ b1 @ b1 @ b0);
ucl_hex_f := ( b1 @ b1 @ b1 @ b1);

RSP := State.rsp;
ESP := State.rsp # [31:0];
SP := State.rsp # [15:0];
DEST0 := case
    OperandSize != bits32 & (StackAddrSize = bits32) : State.memory(ESP);
    OperandSize = bits32 & StackAddrSize = bits32 : State.memory(ESP);
    OperandSize != bits64 & (StackAddrSize = bits64 & StackAddrSize != bits32) : State.memory(RSP);
    OperandSize = bits64 & StackAddrSize = bits64 & StackAddrSize != bits32 : State.memory(RSP);
    OperandSize != bits16 & (StackAddrSize != bits64 & (StackAddrSize != bits32)) : State.memory(SP);
    OperandSize = bits16 & StackAddrSize != bits64 & (StackAddrSize != bits32) : State.memory(SP);
    default : DEST;
esac;

DEST_n := DEST0;

SP0 := case
    OperandSize = bits16 & StackAddrSize != bits64 & (StackAddrSize != bits32) : SP + 2;
    OperandSize != bits16 & (StackAddrSize != bits64 & (StackAddrSize != bits32)) : SP + 4;
    default : SP;
esac;

SP_n := SP0;

RSP0 := case
    OperandSize != bits64 & (StackAddrSize = bits64 & StackAddrSize != bits32) : ( RSP ) +_64 ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_2) );
    OperandSize = bits64 & StackAddrSize = bits64 & StackAddrSize != bits32 : ( RSP ) +_64 ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_8) );
    default : RSP;
esac;

RSP_n := RSP0;

ESP0 := case
    OperandSize = bits32 & StackAddrSize = bits32 : ESP + 4;
    OperandSize != bits32 & (StackAddrSize = bits32) : ESP + 2;
    default : ESP;
esac;

ESP_n := ESP0;


ASSIGN

init[DEST] := DEST_i;
next[DEST] := DEST_n;

init[StackAddrSize] := {bits64, bits32, bits16};
next[StackAddrSize] := {bits64, bits32, bits16};

init[rsp] := rsp_i;
next[rsp] := RSP_n;

init[OperandSize] := {bits64, bits32, bits16};
next[OperandSize] := {bits64, bits32, bits16};


(*----- ./models//syscall.txt -----*)
MODULE syscallInstr

INPUT

State.ss_limit : BITVEC[20];
State.ss_selector : BITVEC[16];
State.rcx : BITVEC[64];
State.rflags : BITVEC[64];
State.r11 : BITVEC[64];
State.ss_base : BITVEC[32];
State.ss_accessRights : BITVEC[12];
State.EFER : BITVEC[64];
State.cs_base : BITVEC[32];
State.rip : BITVEC[64];
State.cs_selector : BITVEC[16];
State.cs_limit : BITVEC[20];
State.cpl : BITVEC[2];
State.cs_accessRights : BITVEC[12];

VAR
ss_base : BITVEC[32];
exitStatus: exitCase;
rcx : BITVEC[64];
r11 : BITVEC[64];
ss_limit : BITVEC[20];
cs_selector : BITVEC[16];
ss_accessRights : BITVEC[12];
rip : BITVEC[64];
cs_accessRights : BITVEC[12];
cs_base : BITVEC[32];
cs_limit : BITVEC[20];
cpl : BITVEC[2];
ss_selector : BITVEC[16];
rflags : BITVEC[64];

CONST
IA32_FMASK: BITVEC[64];
rflags_rfLAGS: BITVEC[64];
IA32_LSTAR: BITVEC[64];
IA32_STAR: BITVEC[64];

ss_base_i : BITVEC[32];
rcx_i : BITVEC[64];
r11_i : BITVEC[64];
ss_limit_i : BITVEC[20];
cs_selector_i : BITVEC[16];
ss_accessRights_i : BITVEC[12];
rip_i : BITVEC[64];
cs_accessRights_i : BITVEC[12];
cs_base_i : BITVEC[32];
cs_limit_i : BITVEC[20];
cpl_i : BITVEC[2];
ss_selector_i : BITVEC[16];
rflags_i : BITVEC[64];

DEFINE

b0 := ( 0 # [0:0] );
b1 := ( 1 # [0:0] );
ucl_hex_0 := ( b0 @ b0 @ b0 @ b0);
ucl_hex_1 := ( b0 @ b0 @ b0 @ b1);
ucl_hex_2 := ( b0 @ b0 @ b1 @ b0);
ucl_hex_3 := ( b0 @ b0 @ b1 @ b1);
ucl_hex_4 := ( b0 @ b1 @ b0 @ b0);
ucl_hex_5 := ( b0 @ b1 @ b0 @ b1);
ucl_hex_6 := ( b0 @ b1 @ b1 @ b0);
ucl_hex_7 := ( b0 @ b1 @ b1 @ b1);
ucl_hex_8 := ( b1 @ b0 @ b0 @ b0);
ucl_hex_9 := ( b1 @ b0 @ b0 @ b1);
ucl_hex_a := ( b1 @ b0 @ b1 @ b0);
ucl_hex_b := ( b1 @ b0 @ b1 @ b1);
ucl_hex_c := ( b1 @ b1 @ b0 @ b0);
ucl_hex_d := ( b1 @ b1 @ b0 @ b1);
ucl_hex_e := ( b1 @ b1 @ b1 @ b0);
ucl_hex_f := ( b1 @ b1 @ b1 @ b1);

RFLAGS := State.rflags;
RCX := State.rcx;
IA32_EFER.SCE := State.EFER # [0:0];
CS.L := State.cs_accessRights # [2:2];
R11 := State.r11;
CPL := State.cpl;
IA32_EFER.LMA := State.EFER # [10:10];
RIP := State.rip;
CS.G := ( b1 );
SS.DPL := ( (b0)@(b0) );
SS.G := ( b1 );
SS.P := ( b1 );
CS.P := ( b1 );
CS.L := ( b1 );
CS.Type := ( (ucl_hex_b) );
CS.D := ( b0 );
SS.S := ( b1 );
CS.DPL := ( (b0)@(b0) );
SS.Type := ( (ucl_hex_3) );
SS.B := ( b1 );
CS.S := ( b1 );
CS.AVL := State.cs_accessRights # [3:3];
CS.B := State.cs_accessRights # [1:1];
SS.AVL := State.ss_accessRights # [3:3];
SS.D := State.ss_accessRights # [1:1];
SS.L := State.ss_accessRights # [2:2];

ASSIGN

init[ss_base] := ss_base_i;
next[ss_base] := case
    next[exitStatus] != UD : ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) );
    default : State.ss_base;
esac;

init[exitStatus] := Normal;
next[exitStatus] := case
    CS.L != 1 | IA32_EFER.LMA != 1 | IA32_EFER.SCE != 1 : UD;
    default : Normal;
esac;

init[rcx] := rcx_i;
next[rcx] := case
    next[exitStatus] != UD : ( RIP );
    default : State.rcx;
esac;

init[r11] := r11_i;
next[r11] := case
    next[exitStatus] != UD : ( rflags_rfLAGS );
    default : State.r11;
esac;

init[ss_limit] := ss_limit_i;
next[ss_limit] := case
    next[exitStatus] != UD : ( (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) );
    default : State.ss_limit;
esac;

init[cs_selector] := cs_selector_i;
next[cs_selector] := case
    next[exitStatus] != UD : ( IA32_STAR # [47:32] ) && ( (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_c) );
    default : State.cs_selector;
esac;

init[ss_accessRights] := ss_accessRights_i;
next[ss_accessRights] := case
    next[exitStatus] != UD : ( ( SS.Type ) ) @ ( ( SS.S ) ) @ ( ( SS.DPL ) ) @ ( ( SS.P ) ) @ ( ( SS.AVL ) ) @ ( ( SS.L ) ) @ ( ( SS.D ) ) @ ( ( SS.B ) ) @ ( ( SS.G ) );
    default : State.ss_accessRights;
esac;

init[rip] := rip_i;
next[rip] := case
    next[exitStatus] != UD : ( IA32_LSTAR );
    default : State.rip;
esac;

init[cs_accessRights] := cs_accessRights_i;
next[cs_accessRights] := case
    next[exitStatus] != UD : ( ( CS.Type ) ) @ ( ( CS.S ) ) @ ( ( CS.DPL ) ) @ ( ( CS.P ) ) @ ( ( CS.AVL ) ) @ ( ( CS.L ) ) @ ( ( CS.D ) ) @ ( ( CS.B ) ) @ ( ( CS.G ) );
    default : State.cs_accessRights;
esac;

init[cs_base] := cs_base_i;
next[cs_base] := case
    next[exitStatus] != UD : ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) );
    default : State.cs_base;
esac;

init[cs_limit] := cs_limit_i;
next[cs_limit] := case
    next[exitStatus] != UD : ( (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) @ (ucl_hex_f) );
    default : State.cs_limit;
esac;

init[cpl] := cpl_i;
next[cpl] := case
    next[exitStatus] != UD : ( (b0)@(b0) );
    default : State.cpl;
esac;

init[ss_selector] := ss_selector_i;
next[ss_selector] := case
    next[exitStatus] != UD : ( IA32_STAR # [47:32] ) +_16 ( (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_0) @ (ucl_hex_8) );
    default : State.ss_selector;
esac;

init[rflags] := rflags_i;
next[rflags] := case
    next[exitStatus] != UD : ( rflags_rfLAGS ) && ( !!IA32_FMASK );
    default : State.rflags;
esac;


(*----- state/vars.txt -----*)
MODULE State

INPUT

opcode : opcodes;

VAR
ss_limit : BITVEC[20];
ss_selector : BITVEC[16];
rax : BITVEC[64];
rbx : BITVEC[64];
rcx : BITVEC[64];
rdx : BITVEC[64];
rflags : BITVEC[64];
r11 : BITVEC[64];
ss_base : BITVEC[32];
ss_accessRights : BITVEC[12];
EFER : BITVEC[64];
cs_base : BITVEC[32];
rip : BITVEC[64];
cs_selector : BITVEC[16];
cs_limit : BITVEC[20];
cpl : BITVEC[2];
cs_accessRights : BITVEC[12];
CR0 : BITVEC[64];
CR4 : BITVEC[64];
currentReg : register;
opcode : opcodes;
memory : FUNC[1];
rsp : BITVEC[64];

CONST

i : TERM;
m0 : FUNC[1];
addr  : BITVEC[64];
SRC : BITVEC[64];

ss_limit_i : BITVEC[20];
ss_selector_i : BITVEC[16];
rax_i : BITVEC[64];
rbx_i : BITVEC[64];
rcx_i : BITVEC[64];
rdx_i : BITVEC[64];
rflags_i : BITVEC[64];
r11_i : BITVEC[64];
ss_base_i : BITVEC[32];
ss_accessRights_i : BITVEC[12];
EFER_i : BITVEC[64];
cs_base_i : BITVEC[32];
rip_i : BITVEC[64];
cs_selector_i : BITVEC[16];
cs_limit_i : BITVEC[20];
cpl_i : BITVEC[2];
cs_accessRights_i : BITVEC[12];
CR0_i : BITVEC[64];
CR4_i : BITVEC[64];
rsp_i : BITVEC[64];

DEFINE

ASSIGN

init[currentReg] := {a, b, c, d};
next[currentReg] := {a, b, c, d};

init[memory] := Lambda(i). m0(i);
next[memory] := Lambda(i).
(* at each step, write "data" into the address "addr" *)
	case
		addr = next[pushInstr.rsp] & opcode = push : SRC; (* only change the content of "addr" *)
		default : memory(i); (* content of other addr remains unchanged *)
	esac;



init[ss_limit] := ss_limit_i;
next[ss_limit] := case
    opcode = sysret : next[sysretInstr.ss_limit];
    opcode = syscall : next[syscallInstr.ss_limit];
    default : ss_limit;
esac;

init[ss_accessRights] := ss_accessRights_i;
next[ss_accessRights] := case
    opcode = sysret : next[sysretInstr.ss_accessRights];
    opcode = syscall : next[syscallInstr.ss_accessRights];
    default : ss_accessRights;
esac;

init[rcx] := rcx_i;
next[rcx] := case
    opcode = mov & currentReg = c : next[movInstr.DEST];
    opcode = pop & currentReg = c : next[popInstr.DEST];
    opcode = syscall : next[syscallInstr.rcx];
    default : rcx;
esac;

init[cs_accessRights] := cs_accessRights_i;
next[cs_accessRights] := case
    opcode = sysret : next[sysretInstr.cs_accessRights];
    opcode = syscall : next[syscallInstr.cs_accessRights];
    default : cs_accessRights;
esac;

init[CR4] := CR4_i;
next[CR4] := CR4;


init[rbx] := rbx_i;
next[rbx] := case
    opcode = mov & currentReg = b : next[movInstr.DEST];
    opcode = pop & currentReg = b : next[popInstr.DEST];
    default : rbx;
esac;

init[ss_base] := ss_base_i;
next[ss_base] := case
    opcode = sysret : next[sysretInstr.ss_base];
    opcode = syscall : next[syscallInstr.ss_base];
    default : ss_base;
esac;

init[cs_base] := cs_base_i;
next[cs_base] := case
    opcode = sysret : next[sysretInstr.cs_base];
    opcode = syscall : next[syscallInstr.cs_base];
    default : cs_base;
esac;

init[r11] := r11_i;
next[r11] := case
    opcode = syscall : next[syscallInstr.r11];
    default : r11;
esac;

init[EFER] := EFER_i;
next[EFER] := EFER;


init[ss_selector] := ss_selector_i;
next[ss_selector] := case
    opcode = sysret : next[sysretInstr.ss_selector];
    opcode = syscall : next[syscallInstr.ss_selector];
    default : ss_selector;
esac;

init[rip] := rip_i;
next[rip] := case
    opcode = sysret : next[sysretInstr.rip];
    opcode = syscall : next[syscallInstr.rip];
    default : rip;
esac;

init[rdx] := rdx_i;
next[rdx] := case
    opcode = mov & currentReg = d : next[movInstr.DEST];
    opcode = pop & currentReg = d : next[popInstr.DEST];
    default : rdx;
esac;

init[cs_limit] := cs_limit_i;
next[cs_limit] := case
    opcode = sysret : next[sysretInstr.cs_limit];
    opcode = syscall : next[syscallInstr.cs_limit];
    default : cs_limit;
esac;

init[cs_selector] := cs_selector_i;
next[cs_selector] := case
    opcode = sysret : next[sysretInstr.cs_selector];
    opcode = syscall : next[syscallInstr.cs_selector];
    default : cs_selector;
esac;

init[CR0] := CR0_i;
next[CR0] := CR0;


init[cpl] := cpl_i;
next[cpl] := case
    opcode = sysret : next[sysretInstr.cpl];
    opcode = syscall : next[syscallInstr.cpl];
    default : cpl;
esac;

init[rsp] := rsp_i;
next[rsp] := case
    opcode = push : next[pushInstr.rsp];
    opcode = pop : next[popInstr.rsp];
    default : rsp;
esac;

init[rflags] := rflags_i;
next[rflags] := case
    opcode = sysret : next[sysretInstr.rflags];
    opcode = syscall : next[syscallInstr.rflags];
    default : rflags;
esac;

init[rax] := rax_i;
next[rax] := case
    opcode = mov & currentReg = a : next[movInstr.DEST];
    opcode = pop & currentReg = a : next[popInstr.DEST];
    default : rax;
esac;

(* ----- CONTROL MODULE ----- *)

CONTROL

EXTVAR

opcode : opcodes := {sysret, push, mov, pop, syscall};

(*----- state/control.txt -----*)
isCanonical : TRUTH := {true, false};

STOREVAR

sysret_rcx : BITVEC[64]; (* RCX before sysret/pop *)
syscall_rcx : BITVEC[64]; (* RCX after syscall/push *)
syscall_rsp : BITVEC[64]; (*RSP before syscall*)
sysret_rsp : BITVEC[64]; (*RSP after sysret*)
sysret_cpl : BITVEC[64]; (*CPL after sysret*)

VAR

CONST

canonical : PRED[1]; (* Predicate to decide whether is canonical or not *)
isUserControlled: PRED[1]; (* Predicate to decide whether stack is user controlled *)

DEFINE

setIsCanonical := case
	canonical(sysret_rcx) : true;
	default : false;
esac;

b0 := 0x0 # [0:0];
b1 := 0x1 # [0:0];

(* Statements begin *)
EXEC
(*----------------------------------------------------------------*)
(* Simulate some number of simulations *)
(* x must changed to an actual  number*)
simulate(5);
(* We need to call syscall and context sw*)
syscall_rsp := State.rsp; 
opcode[6] := syscall;                               (*RCX is set to RSP*)
opcode[7] := push;                                  (*User RSP is sent to the stack*)
(*currentRegister[7] := rsp;*)                          (*Set rsp register to be pushed*)
simulate(2);
syscall_rcx := State.rcx;                             (*RCX must implicitly be canonical*)
(* Simulate some number of simulations *)
(* y must changed to an actual number *)
simulate(4);                                          (*RCX must change to force sysret bug*)
sysret_rcx := State.rcx;
opcode[11] := pop;                                 (*RSP is set to pushed User RSP*)
(*currentRegister[11] := rsp;*)                        (*Set rsp to recieve popped value*)
simulate(1);
sysret_rsp := State.rsp;
opcode[12] := sysret;                              (*Will fault if rcx is not not canonical*)
isCanonical[12] := setIsCanonical;
simulate(1);
sysret_cpl := State.cpl;


decide((canonical(sysret_rcx) & isUserControlled(syscall_rsp) & syscall_rsp = sysret_rsp) => (isUserControlled(sysret_rsp) & sysret_cpl = ((b1)@(b1))));
