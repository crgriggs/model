UCLID
Copyright (C) 2001-2011 The UCLID Team
Compiling model StateModel...
Compiling module sysretInstr...
Compiling module pushInstr...
Compiling module movInstr...
Compiling module popInstr...
Compiling module syscallInstr...
Compiling module State...
Compilation finished for UCLID model StateModel.

INITIAL STATE:

Boolean State:
[State.exceptionThrown:=F
,]

Term State:
[State.rax:=State.rax_i
,pushInstr.memory:=pushInstr.memory_i
,sysretInstr.cs_accessRights:=sysretInstr.cs_accessRights_i
,sysretInstr.cs_limit:=sysretInstr.cs_limit_i
,State.EFER:=State.EFER_i
,popInstr.rsp:=popInstr.rsp_i
,sysretInstr.ss_selector:=sysretInstr.ss_selector_i
,syscallInstr.ss_selector:=syscallInstr.ss_selector_i
,State.rsp:=State.rsp_i
,syscallInstr.cs_base:=syscallInstr.cs_base_i
,movInstr.DEST:=movInstr.DEST_i
,State.rip:=State.rip_i
,State.cs_selector:=State.cs_selector_i
,syscallInstr.rcx:=syscallInstr.rcx_i
,State.rbx:=State.rbx_i
,sysretInstr.ss_accessRights:=sysretInstr.ss_accessRights_i
,State.CR0:=State.CR0_i
,State.ss_limit:=State.ss_limit_i
,syscallInstr.cs_accessRights:=syscallInstr.cs_accessRights_i
,syscallInstr.r11:=syscallInstr.r11_i
,syscallInstr.rflags:=syscallInstr.rflags_i
,syscallInstr.cpl:=syscallInstr.cpl_i
,State.CR4:=State.CR4_i
,syscallInstr.ss_limit:=syscallInstr.ss_limit_i
,pushInstr.rsp:=pushInstr.rsp_i
,sysretInstr.rip:=sysretInstr.rip_i
,sysretInstr.cs_base:=sysretInstr.cs_base_i
,syscallInstr.ss_base:=syscallInstr.ss_base_i
,State.ss_selector:=State.ss_selector_i
,State.cs_base:=State.cs_base_i
,syscallInstr.ss_accessRights:=syscallInstr.ss_accessRights_i
,State.cs_limit:=State.cs_limit_i
,State.rcx:=State.rcx_i
,syscallInstr.cs_limit:=syscallInstr.cs_limit_i
,State.cs_accessRights:=State.cs_accessRights_i
,State.r11:=State.r11_i
,State.cpl:=@([0:0](0x1[4](ZERO_)),[0:0](0x1[4](ZERO_)))
,sysretInstr.rflags:=sysretInstr.rflags_i
,popInstr.DEST:=popInstr.DEST_i
,sysretInstr.ss_base:=sysretInstr.ss_base_i
,State.rflags:=State.rflags_i
,State.ss_base:=State.ss_base_i
,sysretInstr.cpl:=sysretInstr.cpl_i
,sysretInstr.ss_limit:=sysretInstr.ss_limit_i
,State.ss_accessRights:=State.ss_accessRights_i
,State.rdx:=State.rdx_i
,syscallInstr.rip:=syscallInstr.rip_i
,sysretInstr.cs_selector:=sysretInstr.cs_selector_i
,syscallInstr.cs_selector:=syscallInstr.cs_selector_i
,]

Func State:
[State.memory:=Lam(_i0).State.m0(_i0)
,]

Pred State:
[]

Enum State:
[popInstr.OperandSize:=ITE(_p6,bits64,ITE(_p7,bits32,bits16))
,syscallInstr.exitStatus:=Normal
,popInstr.StackAddrSize:=ITE(_p4,bits64,ITE(_p5,bits32,bits16))
,sysretInstr.exitStatus:=Normal
,State.currentReg:=ITE(_p8,a,ITE(_p9,b,ITE(_p10,c,d)))
,pushInstr.OperandSize:=ITE(_p0,bits64,ITE(_p1,bits32,bits16))
,pushInstr.StackAddrSize:=ITE(_p2,bits64,ITE(_p3,bits32,bits16))
,]

External Enum State:
[opcode:=ITE(_p11,sysret,ITE(_p12,push,ITE(_p13,mov,ITE(_p14,pop,syscall))))
,]
Enum Func State:
[]

Simulating...
evaluating State.CR0
evaluating State.CR4
evaluating State.EFER
evaluating State.currentReg
evaluating movInstr.DEST
evaluating popInstr.DEST
evaluating State.rax
evaluating State.rbx
evaluating State.rdx
evaluating popInstr.OperandSize
evaluating popInstr.StackAddrSize
evaluating popInstr.rsp
evaluating pushInstr.OperandSize
evaluating pushInstr.StackAddrSize
evaluating pushInstr.memory
evaluating pushInstr.rsp
evaluating State.memory
evaluating State.rsp
evaluating syscallInstr.cpl
evaluating syscallInstr.exitStatus
evaluating syscallInstr.cs_accessRights
evaluating syscallInstr.cs_base
evaluating syscallInstr.cs_limit
evaluating syscallInstr.cs_selector
evaluating syscallInstr.r11
evaluating State.r11
evaluating syscallInstr.rcx
evaluating State.rcx
evaluating syscallInstr.rflags
evaluating syscallInstr.rip
evaluating syscallInstr.ss_accessRights
evaluating syscallInstr.ss_base
evaluating syscallInstr.ss_limit
evaluating syscallInstr.ss_selector
evaluating sysretInstr.exitStatus
.evaluating sysretInstr.cpl
evaluating State.cpl
evaluating sysretInstr.cs_accessRights
evaluating State.cs_accessRights
evaluating sysretInstr.cs_base
evaluating State.cs_base
evaluating sysretInstr.cs_limit
evaluating State.cs_limit
evaluating sysretInstr.cs_selector
evaluating State.cs_selector
evaluating sysretInstr.rflags
evaluating State.rflags
evaluating sysretInstr.rip
evaluating State.rip
evaluating sysretInstr.ss_accessRights
evaluating State.ss_accessRights
evaluating sysretInstr.ss_base
evaluating State.ss_base
evaluating sysretInstr.ss_limit
evaluating State.ss_limit
evaluating sysretInstr.ss_selector
evaluating State.ss_selector
 step 1 complete
evaluating State.CR0
evaluating State.CR4
evaluating State.EFER
evaluating State.currentReg
evaluating movInstr.DEST
evaluating popInstr.DEST
evaluating State.rax
evaluating State.rbx
evaluating State.rdx
evaluating popInstr.OperandSize
evaluating popInstr.StackAddrSize
evaluating popInstr.rsp
evaluating pushInstr.OperandSize
evaluating pushInstr.StackAddrSize
evaluating pushInstr.memory
evaluating pushInstr.rsp
evaluating State.memory
evaluating State.rsp
evaluating syscallInstr.cpl
evaluating syscallInstr.exitStatus
evaluating syscallInstr.cs_accessRights
evaluating syscallInstr.cs_base
evaluating syscallInstr.cs_limit
evaluating syscallInstr.cs_selector
evaluating syscallInstr.r11
evaluating State.r11
evaluating syscallInstr.rcx
evaluating State.rcx
evaluating syscallInstr.rflags
evaluating syscallInstr.rip
evaluating syscallInstr.ss_accessRights
evaluating syscallInstr.ss_base
evaluating syscallInstr.ss_limit
evaluating syscallInstr.ss_selector
evaluating sysretInstr.exitStatus
.evaluating sysretInstr.cpl
evaluating State.cpl
evaluating sysretInstr.cs_accessRights
evaluating State.cs_accessRights
evaluating sysretInstr.cs_base
evaluating State.cs_base
evaluating sysretInstr.cs_limit
evaluating State.cs_limit
evaluating sysretInstr.cs_selector
evaluating State.cs_selector
evaluating sysretInstr.rflags
evaluating State.rflags
evaluating sysretInstr.rip
evaluating State.rip
evaluating sysretInstr.ss_accessRights
evaluating State.ss_accessRights
evaluating sysretInstr.ss_base
evaluating State.ss_base
evaluating sysretInstr.ss_limit
evaluating State.ss_limit
evaluating sysretInstr.ss_selector
evaluating State.ss_selector
 step 2 complete
Simulating...
evaluating State.CR0
evaluating State.CR4
evaluating State.EFER
evaluating State.currentReg
evaluating movInstr.DEST
evaluating popInstr.DEST
evaluating State.rax
evaluating State.rbx
evaluating State.rdx
evaluating popInstr.OperandSize
evaluating popInstr.StackAddrSize
evaluating popInstr.rsp
evaluating pushInstr.OperandSize
evaluating pushInstr.StackAddrSize
evaluating pushInstr.memory
evaluating pushInstr.rsp
evaluating State.memory
evaluating State.rsp
evaluating syscallInstr.cpl
evaluating syscallInstr.exitStatus
evaluating syscallInstr.cs_accessRights
evaluating syscallInstr.cs_base
evaluating syscallInstr.cs_limit
evaluating syscallInstr.cs_selector
evaluating syscallInstr.r11
evaluating State.r11
evaluating syscallInstr.rcx
evaluating State.rcx
evaluating syscallInstr.rflags
evaluating syscallInstr.rip
evaluating syscallInstr.ss_accessRights
evaluating syscallInstr.ss_base
evaluating syscallInstr.ss_limit
evaluating syscallInstr.ss_selector
evaluating sysretInstr.exitStatus
.evaluating sysretInstr.cpl
evaluating State.cpl
evaluating sysretInstr.cs_accessRights
evaluating State.cs_accessRights
evaluating sysretInstr.cs_base
evaluating State.cs_base
evaluating sysretInstr.cs_limit
evaluating State.cs_limit
evaluating sysretInstr.cs_selector
evaluating State.cs_selector
evaluating sysretInstr.rflags
evaluating State.rflags
evaluating sysretInstr.rip
evaluating State.rip
evaluating sysretInstr.ss_accessRights
evaluating State.ss_accessRights
evaluating sysretInstr.ss_base
evaluating State.ss_base
evaluating sysretInstr.ss_limit
evaluating State.ss_limit
evaluating sysretInstr.ss_selector
evaluating State.ss_selector
 step 3 complete
Simulating...
evaluating State.CR0
evaluating State.CR4
evaluating State.EFER
evaluating State.currentReg
evaluating movInstr.DEST
evaluating popInstr.DEST
evaluating State.rax
evaluating State.rbx
evaluating State.rdx
evaluating popInstr.OperandSize
evaluating popInstr.StackAddrSize
evaluating popInstr.rsp
evaluating pushInstr.OperandSize
evaluating pushInstr.StackAddrSize
evaluating pushInstr.memory
evaluating pushInstr.rsp
evaluating State.memory
evaluating State.rsp
evaluating syscallInstr.cpl
evaluating syscallInstr.exitStatus
evaluating syscallInstr.cs_accessRights
evaluating syscallInstr.cs_base
evaluating syscallInstr.cs_limit
evaluating syscallInstr.cs_selector
evaluating syscallInstr.r11
evaluating State.r11
evaluating syscallInstr.rcx
evaluating State.rcx
evaluating syscallInstr.rflags
evaluating syscallInstr.rip
evaluating syscallInstr.ss_accessRights
evaluating syscallInstr.ss_base
evaluating syscallInstr.ss_limit
evaluating syscallInstr.ss_selector
evaluating sysretInstr.exitStatus
.evaluating sysretInstr.cpl
evaluating State.cpl
evaluating sysretInstr.cs_accessRights
evaluating State.cs_accessRights
evaluating sysretInstr.cs_base
evaluating State.cs_base
evaluating sysretInstr.cs_limit
evaluating State.cs_limit
evaluating sysretInstr.cs_selector
evaluating State.cs_selector
evaluating sysretInstr.rflags
evaluating State.rflags
evaluating sysretInstr.rip
evaluating State.rip
evaluating sysretInstr.ss_accessRights
evaluating State.ss_accessRights
evaluating sysretInstr.ss_base
evaluating State.ss_base
evaluating sysretInstr.ss_limit
evaluating State.ss_limit
evaluating sysretInstr.ss_selector
evaluating State.ss_selector
 step 4 complete

**********************************************
     Decision Procedure 
**********************************************

**********************************************
Using heuristic  1
Ignoring Positive Equality Analysis....
Using Ackermann's method to eliminate g-function symbols....
**********************************************
Stats : Original formula size :<|tnodes|,|Tnodes|> = <116,147>
Getting function, predicate symbols.....
Getting the PCEUF from the formula.....
Initializing function application classes...
Initial number of fAppClasses is 100
Final number of fAppClasses is 1

 the function symbols:[State.EFER_i,State.cs_accessRights_i,State.rsp_i,ZERO_,__en_exitCase,__en_opcodes,__en_size]

 the individual variables:[State.EFER_i,State.cs_accessRights_i,State.rsp_i,ZERO_,__en_exitCase,__en_opcodes,__en_size]

 the p function symbols:[]
Eliminating  uninterpreted g-func/pred symbols Ackermann.....
Eliminating  uninterpreted p-func symbols Bryant.....
# of vars  = 7
# of pvars = 0
# of gvars = 7

 the p-vars :[]

 the g-vars:[State.EFER_i,State.cs_accessRights_i,State.rsp_i,ZERO_,__en_exitCase,__en_opcodes,__en_size]
Fraction of p-vars = 0.0
Stats :  after function elimination  size :<|tnodes|,|Tnodes|> = <116,147>
Stats :  after predicate elimination  size :<|tnodes|,|Tnodes|> = <116,147>
# of ITE vars = 0
The final variable classes :
{[State.EFER_i], true, Cardinality = 1}
{[State.cs_accessRights_i], true, Cardinality = 1}
{[State.rsp_i], true, Cardinality = 1}
{[ZERO_], false, Cardinality = 1}
{[__en_exitCase], true, Cardinality = 1}
{[__en_opcodes], true, Cardinality = 1}
{[__en_size], true, Cardinality = 1}
Starting Eager Encoding for Bit-Vector Arithmetic...
Generating propositional encoding...
#bits for State.rsp_i = 64
#bits for __en_exitCase = 0 (constant encoding of 4)
#bits for State.cs_accessRights_i = 12
#bits for State.EFER_i = 64
#bits for __en_opcodes = 0 (constant encoding of 5)
#bits for __en_size = 0 (constant encoding of 6)
User Time for propositional encoding: 0.028


 Overall Bit-Vector Encoding Time
Encoding Usr Time: 0.028
Encoding Sys Time: 0.000

+++ No Counter-Examples Found : Formula trivially Valid +++



 Decision Procedure Encoding Time
Usr Time: 0.044
Sys Time: 0.000


 Overall ML Execution Time
Usr Time: 0.060
Sys Time: 0.000
